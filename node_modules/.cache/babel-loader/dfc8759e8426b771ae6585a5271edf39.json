{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar MediaTagReader = require('./MediaTagReader');\n\nvar MediaFileReader = require('./MediaFileReader');\n\nvar ID3v2FrameReader = require('./ID3v2FrameReader');\n\nvar ID3_HEADER_SIZE = 10;\n\nvar ID3v2TagReader = function (_MediaTagReader) {\n  _inherits(ID3v2TagReader, _MediaTagReader);\n\n  function ID3v2TagReader() {\n    _classCallCheck(this, ID3v2TagReader);\n\n    return _possibleConstructorReturn(this, (ID3v2TagReader.__proto__ || Object.getPrototypeOf(ID3v2TagReader)).apply(this, arguments));\n  }\n\n  _createClass(ID3v2TagReader, [{\n    key: '_loadData',\n    value: function _loadData(mediaFileReader, callbacks) {\n      mediaFileReader.loadRange([6, 9], {\n        onSuccess: function onSuccess() {\n          mediaFileReader.loadRange( // The tag size does not include the header size.\n          [0, ID3_HEADER_SIZE + mediaFileReader.getSynchsafeInteger32At(6) - 1], callbacks);\n        },\n        onError: callbacks.onError\n      });\n    }\n  }, {\n    key: '_parseData',\n    value: function _parseData(data, tags) {\n      var offset = 0;\n      var major = data.getByteAt(offset + 3);\n\n      if (major > 4) {\n        return {\n          \"type\": \"ID3\",\n          \"version\": \">2.4\",\n          \"tags\": {}\n        };\n      }\n\n      var revision = data.getByteAt(offset + 4);\n      var unsynch = data.isBitSetAt(offset + 5, 7);\n      var xheader = data.isBitSetAt(offset + 5, 6);\n      var xindicator = data.isBitSetAt(offset + 5, 5);\n      var size = data.getSynchsafeInteger32At(offset + 6);\n      offset += 10;\n\n      if (xheader) {\n        // TODO: support 2.4\n        var xheadersize = data.getLongAt(offset, true); // The 'Extended header size', currently 6 or 10 bytes, excludes itself.\n\n        offset += xheadersize + 4;\n      }\n\n      var id3 = {\n        \"type\": \"ID3\",\n        \"version\": '2.' + major + '.' + revision,\n        \"major\": major,\n        \"revision\": revision,\n        \"flags\": {\n          \"unsynchronisation\": unsynch,\n          \"extended_header\": xheader,\n          \"experimental_indicator\": xindicator,\n          // TODO: footer_present\n          \"footer_present\": false\n        },\n        \"size\": size,\n        \"tags\": {}\n      };\n\n      if (tags) {\n        var expandedTags = this._expandShortcutTags(tags);\n      }\n\n      var offsetEnd = size + 10\n      /*header size*/\n      ; // When this flag is set the entire tag needs to be un-unsynchronised\n      // before parsing each individual frame. Individual frame sizes might not\n      // take unsynchronisation into consideration when it's set on the tag\n      // header.\n\n      if (id3.flags.unsynchronisation) {\n        data = ID3v2FrameReader.getUnsyncFileReader(data, offset, size);\n        offset = 0;\n        offsetEnd = data.getSize();\n      }\n\n      var frames = ID3v2FrameReader.readFrames(offset, offsetEnd, data, id3, expandedTags); // create shortcuts for most common data.\n\n      for (var name in SHORTCUTS) {\n        if (SHORTCUTS.hasOwnProperty(name)) {\n          var frameData = this._getFrameData(frames, SHORTCUTS[name]);\n\n          if (frameData) {\n            id3.tags[name] = frameData;\n          }\n        }\n      }\n\n      for (var frame in frames) {\n        if (frames.hasOwnProperty(frame)) {\n          id3.tags[frame] = frames[frame];\n        }\n      }\n\n      return id3;\n    }\n  }, {\n    key: '_getFrameData',\n    value: function _getFrameData(frames, ids) {\n      var frame;\n\n      for (var i = 0, id; id = ids[i]; i++) {\n        if (id in frames) {\n          if (frames[id] instanceof Array) {\n            frame = frames[id][0];\n          } else {\n            frame = frames[id];\n          }\n\n          return frame.data;\n        }\n      }\n    }\n  }, {\n    key: 'getShortcuts',\n    value: function getShortcuts() {\n      return SHORTCUTS;\n    }\n  }], [{\n    key: 'getTagIdentifierByteRange',\n    value: function getTagIdentifierByteRange() {\n      // ID3 header\n      return {\n        offset: 0,\n        length: ID3_HEADER_SIZE\n      };\n    }\n  }, {\n    key: 'canReadTagFormat',\n    value: function canReadTagFormat(tagIdentifier) {\n      var id = String.fromCharCode.apply(String, tagIdentifier.slice(0, 3));\n      return id === 'ID3';\n    }\n  }]);\n\n  return ID3v2TagReader;\n}(MediaTagReader);\n\nvar SHORTCUTS = {\n  \"title\": [\"TIT2\", \"TT2\"],\n  \"artist\": [\"TPE1\", \"TP1\"],\n  \"album\": [\"TALB\", \"TAL\"],\n  \"year\": [\"TYER\", \"TYE\"],\n  \"comment\": [\"COMM\", \"COM\"],\n  \"track\": [\"TRCK\", \"TRK\"],\n  \"genre\": [\"TCON\", \"TCO\"],\n  \"picture\": [\"APIC\", \"PIC\"],\n  \"lyrics\": [\"USLT\", \"ULT\"]\n};\nmodule.exports = ID3v2TagReader;","map":null,"metadata":{},"sourceType":"script"}