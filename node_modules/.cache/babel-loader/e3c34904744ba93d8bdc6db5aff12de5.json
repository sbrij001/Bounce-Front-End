{"ast":null,"code":"import _ from \"lodash\";\nimport Supercluster from \"supercluster\";\nimport { getCoord } from \"@turf/invariant\";\nimport { LngLatBounds } from \"mapbox-gl\";\nimport { GeoJSONTypes, CollectionTypes, ListKeysByType } from \"../constants/GeoJSONTypes\";\nvar RADIUS_TO_EXTENDS = 200;\n\nvar checkCollectionGeoJSON = function checkCollectionGeoJSON(data) {\n  return CollectionTypes.indexOf(data.type) !== -1;\n};\n\nvar createBoundsFromCoordinates = function createBoundsFromCoordinates(coordinates, bounds) {\n  if (bounds == null) {\n    return new LngLatBounds(coordinates, coordinates);\n  }\n\n  return bounds.extend(coordinates);\n};\n\nvar extendBounds = function extendBounds(boundary) {\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  var boundObj = new LngLatBounds(boundary);\n  var ne = boundObj.getNorthEast();\n  var neBound = ne.toBounds(radius / 2);\n  var sw = boundObj.getSouthWest();\n  var swBound = sw.toBounds(radius / 2);\n  return _.flatten([swBound.getSouthWest().toArray(), neBound.getNorthEast().toArray()]);\n};\n\nvar flattenCoordinates = function flattenCoordinates(coordinates, positionType) {\n  var depth;\n\n  switch (positionType) {\n    case GeoJSONTypes.MultiPoint:\n    case GeoJSONTypes.LineString:\n      depth = 0;\n      break;\n\n    case GeoJSONTypes.Polygon:\n    case GeoJSONTypes.MultiLineString:\n      depth = 1;\n      break;\n\n    case GeoJSONTypes.MultiPolygon:\n      depth = 2;\n      break;\n\n    case GeoJSONTypes.Point:\n    default:\n      depth = -1;\n  }\n\n  if (depth === -1) {\n    return [coordinates];\n  }\n\n  return _.flattenDepth(coordinates, depth);\n};\n\nvar getCoordinateForPosition = function getCoordinateForPosition(position) {\n  var geoJSONType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GeoJSONTypes.FeatureCollection;\n\n  if (geoJSONType === GeoJSONTypes.FeatureCollection) {\n    return position.geometry.coordinates;\n  }\n\n  return position.coordinates;\n};\n\nvar getFeatureList = function getFeatureList(geoJSON) {\n  var type = geoJSON.type;\n  var key = ListKeysByType[type];\n  return geoJSON[key];\n};\n\nvar getTypeForPosition = function getTypeForPosition(position, geoJSONType) {\n  if (geoJSONType === GeoJSONTypes.FeatureCollection) {\n    return position.geometry.type;\n  }\n\n  return position.type;\n};\n\nvar roundCoords = function roundCoords(coords) {\n  return [_.round(coords[0], 4), _.round(coords[1], 4)];\n};\n/**\n * Calculate the boundary of a geojson\n * @param {object} data a geojson in any format\n * @param? {*} totalBounds [Optional] if given, the boundary will be calculated base on the current \"totalBounds\"\n * @return {LngLatBounds} the total boundary\n */\n\n\nvar calculateBoundary = function calculateBoundary(data) {\n  var totalBounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var type = data.type;\n\n  if (checkCollectionGeoJSON(data)) {\n    var features = getFeatureList(data);\n    features.forEach(function (feature) {\n      var coordinates = getCoordinateForPosition(feature, type);\n      var featureType = getTypeForPosition(feature, type);\n      coordinates = flattenCoordinates(coordinates, featureType);\n\n      if (!_.isArray(coordinates)) {\n        return totalBounds;\n      }\n\n      if (!totalBounds) {\n        totalBounds = new LngLatBounds(coordinates[0], coordinates[0]);\n      }\n\n      totalBounds = coordinates.reduce(function (bounds, coord) {\n        return bounds.extend(coord);\n      }, totalBounds);\n    });\n    return totalBounds;\n  }\n\n  var coordinates = getCoord(data);\n  return createBoundsFromCoordinates(coordinates, totalBounds);\n};\n/**\n * Find the list of point that inside a specific radius\n * @param {FeatureCollection<Point>} data Required. A FeatureCollection of Point type\n * @param {MapBox} mapBox Required. The mapbox instance\n * @param {number} zoom The zoom level, at which the points is clustered\n * @return {Array<Feature>} The list of feature\n */\n\n\nvar createClusters = function createClusters(data, mapBox) {\n  var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n  var zoom = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!data || !data.features || !_.isArray(data.features)) {\n    throw new Error(\"Data cannot be empty\");\n  }\n\n  if (!mapBox) {\n    throw new Error(\"Mapbox instance must be provided\");\n  }\n\n  var superC = new Supercluster({\n    radius: radius,\n    maxZoom: mapBox.getMaxZoom()\n  });\n  var featureList = getFeatureList(data);\n  superC.load(featureList);\n\n  if (!zoom) {\n    zoom = mapBox.getZoom();\n  }\n\n  var boundary = _.isEmpty(featureList) ? [0, 0, 0, 0] : _.flatten(calculateBoundary(data).toArray()); // in case of all points at the same location,\n  // extends its coords by 200 meters radius to make superC work.\n\n  boundary = extendBounds(boundary, RADIUS_TO_EXTENDS);\n  var clusters = featureList.length > 1 ? superC.getClusters(boundary, Math.round(zoom)) : featureList;\n  return {\n    superC: superC,\n    clusters: clusters\n  };\n};\n/**\n * Find the list of point that have a similar location (lngLat)\n * @param {FeatureCollection<Point>} data Required. A FeatureCollection of Point type\n * @param {Coordinate} lngLat Required. The coordinate follow format [longitude, latitude]\n * @param {MapBox} mapBox Required. The mapbox instance\n * @param {number} radius The radius of the cluster\n * @param {number} zoom The zoom level, at which the points is clustered\n * @return {Array<Feature>} The list of point at the same location. Null if cannot find the\n * similar points\n */\n\n\nvar findPointsWithSameLocation = function findPointsWithSameLocation(data, lngLat, mapBox) {\n  var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n  var zoom = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (!data || !data.features || !_.isArray(data.features)) {\n    throw new Error(\"Data cannot be empty\");\n  }\n\n  if (!lngLat || !_.isArray(lngLat)) {\n    throw new Error(\"Specific location cannot be empty\");\n  }\n\n  if (!mapBox) {\n    throw new Error(\"Mapbox instance must be provided\");\n  }\n\n  var _createClusters = createClusters(data, mapBox, radius, zoom),\n      clusters = _createClusters.clusters,\n      superC = _createClusters.superC;\n\n  var clusterAtLngLat = clusters.find(function (cluster) {\n    return _.isEqual(roundCoords(cluster.geometry.coordinates), roundCoords(lngLat));\n  });\n\n  if (clusterAtLngLat) {\n    var _clusterAtLngLat$prop = clusterAtLngLat.properties,\n        cluster = _clusterAtLngLat$prop.cluster,\n        cluster_id = _clusterAtLngLat$prop.cluster_id,\n        point_count = _clusterAtLngLat$prop.point_count;\n\n    if (cluster && point_count > 1) {\n      try {\n        return superC.getLeaves(cluster_id, Infinity);\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Group the list of point that inside a specific radius\n * @param {FeatureCollection<Point>} data Required. A FeatureCollection of Point type\n * @param {MapBox} mapBox Required. The mapbox instance\n * @param {number} radius Optional. The radius of the cluster\n * @return {Array<Array<Feature>>} The list of grouped feature\n */\n\n\nvar groupNearestPointsByRadius = function groupNearestPointsByRadius(data, mapBox) {\n  var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n  if (!data || !data.features || !_.isArray(data.features)) {\n    throw new Error(\"Data cannot be empty\");\n  }\n\n  if (!mapBox) {\n    throw new Error(\"Mapbox instance must be provided\");\n  }\n\n  var zoom = mapBox.getMaxZoom() - 2;\n\n  var _createClusters2 = createClusters(data, mapBox, radius, zoom),\n      clusters = _createClusters2.clusters,\n      superC = _createClusters2.superC;\n\n  clusters = clusters.map(function (cluster) {\n    var _cluster$properties = cluster.properties,\n        isCluster = _cluster$properties.cluster,\n        cluster_id = _cluster$properties.cluster_id;\n\n    if (isCluster) {\n      try {\n        return superC.getLeaves(cluster_id, Infinity);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    return [cluster];\n  });\n  return _.filter(clusters);\n};\n\nexport { createClusters, findPointsWithSameLocation, groupNearestPointsByRadius };","map":null,"metadata":{},"sourceType":"module"}