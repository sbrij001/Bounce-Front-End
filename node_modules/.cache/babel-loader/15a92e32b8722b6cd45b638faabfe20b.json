{"ast":null,"code":"import _objectSpread from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thuanbui/source_code/react-mapbox-gl-cluster/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport _ from \"lodash\";\nimport { checkPropsChange } from \"../utils\";\nimport { ReactMapboxGlSpiderifier } from \"react-mapbox-gl-spiderifier\";\nimport { getCoord } from \"@turf/invariant\";\nimport { findPointsWithSameLocation, groupNearestPointsByRadius } from \"../utils\";\nimport { ClusterOptions } from \"../constants/ClusterOptions\";\nimport MappedComponent from \"../../components/MappedComponent\";\nimport \"./spiderifier.css\";\n\nvar connectWithSpiderifierPoint = function connectWithSpiderifierPoint(WrappedComponent) {\n  var ConnectedWithSpiderifierComponent =\n  /*#__PURE__*/\n  function (_MappedComponent) {\n    _inherits(ConnectedWithSpiderifierComponent, _MappedComponent);\n\n    function ConnectedWithSpiderifierComponent(props) {\n      var _this;\n\n      _classCallCheck(this, ConnectedWithSpiderifierComponent);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectedWithSpiderifierComponent).call(this, props));\n\n      _this.onClickOverlappedPoints = function (points, coordinates) {\n        _this._updateSpiderifierProps([points], coordinates);\n      };\n\n      _this.onMapChange = function () {\n        var onlySpiderifier = _this.props.onlySpiderifier;\n\n        if (!onlySpiderifier && _.isArray(_this._spiderifieredLocations)) {\n          var _this$props = _this.props,\n              data = _this$props.data,\n              radius = _this$props.radius;\n\n          var map = _this.getMapInstance();\n\n          _this._spiderifieredLocations.forEach(function (lngLat) {\n            var points = findPointsWithSameLocation(data, lngLat, map, radius);\n\n            if (!points) {\n              _this.onSpiderifierRemoved(lngLat);\n            }\n          });\n        }\n      };\n\n      _this.state = {\n        overlappedPointsGroup: null\n      };\n      _this.registeredEvents = false;\n      return _this;\n    }\n\n    _createClass(ConnectedWithSpiderifierComponent, [{\n      key: \"componentWillMount\",\n      value: function componentWillMount() {\n        this._updatePoints();\n\n        this.bindEvents();\n      }\n    }, {\n      key: \"componentWillReceiveProps\",\n      value: function componentWillReceiveProps(nextProps) {\n        this._checkAndUpdatePoints(nextProps);\n\n        this.bindEvents();\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        return checkPropsChange(this.props, nextProps, [\"data\", \"showInitialSpiderifier\", \"onlySpiderifier\", \"circleFootSeparation\", \"transformSpiderLeft\", \"showingLegs\"], _.isEqual) || !_.isEqual(this.state, nextState);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.unbindEvents();\n      }\n    }, {\n      key: \"bindEvents\",\n      value: function bindEvents() {\n        var map = this.getMapInstance();\n\n        if (map && !this.registeredEvents) {\n          map.on(\"zoomend\", this.onMapChange);\n          this.registeredEvents = true;\n        }\n      }\n    }, {\n      key: \"unbindEvents\",\n      value: function unbindEvents() {\n        var map = this.getMapInstance();\n\n        if (map) {\n          map.off(\"zoomend\", this.onMapChange);\n        }\n      }\n    }, {\n      key: \"onSpiderifierRemoved\",\n      value: function onSpiderifierRemoved(lngLat) {\n        var overlappedPointsGroup = this.state.overlappedPointsGroup;\n\n        if (_.isArray(overlappedPointsGroup)) {\n          var removedIndex = overlappedPointsGroup.findIndex(function (_ref) {\n            var coordinates = _ref.coordinates;\n            return _.isEqual(coordinates, lngLat);\n          });\n\n          if (removedIndex > -1) {\n            var newGroup = [].concat(_toConsumableArray(overlappedPointsGroup.slice(0, removedIndex)), _toConsumableArray(overlappedPointsGroup.slice(removedIndex + 1)));\n            this.setState({\n              overlappedPointsGroup: newGroup\n            });\n          }\n        }\n\n        var onSpiderifierRemoved = this.props.onSpiderifierRemoved;\n\n        if (_.isFunction(onSpiderifierRemoved)) {\n          onSpiderifierRemoved(lngLat);\n        }\n      }\n    }, {\n      key: \"_checkAndUpdatePoints\",\n      value: function _checkAndUpdatePoints(nextProps) {\n        if (checkPropsChange(this.props, nextProps, [\"data\", \"showInitialSpiderifier\", \"onlySpiderifier\"], _.isEqual)) {\n          this._updatePoints(nextProps);\n        }\n      }\n    }, {\n      key: \"_getComponentProps\",\n      value: function _getComponentProps(propTypes) {\n        var keys = _.map(propTypes, function (value, propKey) {\n          return propKey;\n        });\n\n        return _.pick(this.props, keys);\n      }\n    }, {\n      key: \"_getWrappedComponentProps\",\n      value: function _getWrappedComponentProps() {\n        return this._getComponentProps(WrappedComponent.propTypes);\n      }\n    }, {\n      key: \"_getSpiderifierComponentProps\",\n      value: function _getSpiderifierComponentProps() {\n        return this._getComponentProps(ReactMapboxGlSpiderifier.propTypes);\n      }\n    }, {\n      key: \"_groupNearestPoint\",\n      value: function _groupNearestPoint(props) {\n        var data = props.data,\n            showInitialSpiderifier = props.showInitialSpiderifier,\n            onlySpiderifier = props.onlySpiderifier;\n        var map = this.getMapInstance();\n        var groupedPoints = groupNearestPointsByRadius(data, map, ClusterOptions.NearestPointsRadius);\n\n        if (groupedPoints.length > 0) {\n          if (onlySpiderifier && groupedPoints.length === 1) {\n            this._updateSpiderifierProps(groupedPoints);\n          } else if (showInitialSpiderifier) {\n            var firstGroup = groupedPoints.find(function (group) {\n              return group.length > 1;\n            });\n\n            if (firstGroup == null) {\n              firstGroup = groupedPoints[0];\n            }\n\n            this._updateSpiderifierProps([firstGroup]);\n          }\n        }\n      }\n    }, {\n      key: \"_processSpiderifyProperties\",\n      value: function _processSpiderifyProperties(props) {\n        var spiderifyPropsProcessor = this.props.spiderifyPropsProcessor;\n\n        if (_.isFunction(spiderifyPropsProcessor)) {\n          return spiderifyPropsProcessor(props);\n        }\n\n        return props;\n      }\n    }, {\n      key: \"_renderSpiderifierContent\",\n      value: function _renderSpiderifierContent(key, properties) {\n        return React.createElement(\"div\", {\n          className: \"spiderifier-marker-content\",\n          key: key,\n          properties: properties\n        }, React.createElement(\"div\", null, properties.label));\n      }\n    }, {\n      key: \"_renderSpiderifier\",\n      value: function _renderSpiderifier() {\n        var _this2 = this;\n\n        var overlappedPointsGroup = this.state.overlappedPointsGroup;\n\n        if (overlappedPointsGroup && overlappedPointsGroup.length > 0) {\n          var spiderifierComponentProps = this._getSpiderifierComponentProps();\n\n          return overlappedPointsGroup.map(function (overlappedPoints, index) {\n            var coordinates = overlappedPoints.coordinates,\n                markers = overlappedPoints.markers;\n            return React.createElement(ReactMapboxGlSpiderifier, Object.assign({\n              key: index\n            }, spiderifierComponentProps, {\n              coordinates: coordinates\n            }), markers.map(function (marker, index) {\n              return _this2._renderSpiderifierContent(index, marker);\n            }));\n          });\n        }\n\n        return null;\n      }\n    }, {\n      key: \"_shouldRenderClusterLayer\",\n      value: function _shouldRenderClusterLayer() {\n        var _this$props2 = this.props,\n            onlySpiderifier = _this$props2.onlySpiderifier,\n            overlappedPointsGroup = _this$props2.overlappedPointsGroup;\n        return !onlySpiderifier || !overlappedPointsGroup || overlappedPointsGroup.length > 1;\n      }\n    }, {\n      key: \"_updatePoints\",\n      value: function _updatePoints() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n        var data = props.data,\n            showInitialSpiderifier = props.showInitialSpiderifier,\n            onlySpiderifier = props.onlySpiderifier;\n\n        if (data != null && (showInitialSpiderifier || onlySpiderifier)) {\n          this._groupNearestPoint(props);\n        }\n      }\n    }, {\n      key: \"_updateSpiderifierProps\",\n      value: function _updateSpiderifierProps(group, coordinates) {\n        var _this3 = this;\n\n        this._spiderifieredLocations = [];\n\n        if (group.length > 0) {\n          var overlappedPointsGroup = group.map(function (points) {\n            if (points.length > 0) {\n              var properties = points.map(function (feature) {\n                return feature.properties;\n              });\n              var coords = coordinates;\n\n              if (coords == null) {\n                coords = getCoord(points[0]);\n              }\n\n              return {\n                markers: _this3._processSpiderifyProperties(properties),\n                coordinates: coords\n              };\n            }\n\n            return null;\n          });\n          var onShowSpiderifier = this.props.onShowSpiderifier;\n          overlappedPointsGroup.forEach(function (group) {\n            var coordinates = group.coordinates,\n                markers = group.markers;\n\n            _this3._spiderifieredLocations.push(coordinates);\n\n            if (_.isFunction(onShowSpiderifier)) {\n              onShowSpiderifier(coordinates, markers);\n            }\n          });\n          this.setState({\n            overlappedPointsGroup: overlappedPointsGroup\n          });\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var wrappedComponentProps = this._getWrappedComponentProps();\n\n        return React.createElement(\"div\", null, this._shouldRenderClusterLayer() && React.createElement(WrappedComponent, Object.assign({}, wrappedComponentProps, {\n          onClickOverlappedPoints: this.onClickOverlappedPoints\n        })), this._renderSpiderifier());\n      }\n    }]);\n\n    return ConnectedWithSpiderifierComponent;\n  }(MappedComponent);\n\n  var spiderifierPropTypes = _.pickBy(ReactMapboxGlSpiderifier.propTypes, function (value, props) {\n    return props !== \"markers\" && props !== \"coordinates\";\n  });\n\n  ConnectedWithSpiderifierComponent.propTypes = _objectSpread({}, WrappedComponent.propTypes, spiderifierPropTypes, {\n    /**\n     * Indicate if the spiderifier should be shown for the first overlapped point onload\n     */\n    showInitialSpiderifier: PropTypes.bool,\n\n    /**\n     * Indicate if the spiderifier should be shown without wrapped component\n     */\n    onlySpiderifier: PropTypes.bool,\n\n    /**\n     * Handler to transform the properties of each point\n     */\n    spiderifyPropsProcessor: PropTypes.func,\n\n    /**\n     * Callback when a spiderifier shown\n     */\n    onShowSpiderifier: PropTypes.func,\n\n    /**\n     * [Optional] Handle when user do zoom/move to change the map and made the points\n     * on the map changed and don't have overlapped points anymore\n     */\n    onSpiderifierRemoved: PropTypes.func\n  });\n  ConnectedWithSpiderifierComponent.defaultProps = _objectSpread({}, WrappedComponent.defaultProps, ReactMapboxGlSpiderifier.defaultProps);\n  return ConnectedWithSpiderifierComponent;\n};\n\nexport default connectWithSpiderifierPoint;","map":null,"metadata":{},"sourceType":"module"}